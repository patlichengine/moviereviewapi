"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IN_MEMORY = exports.isSqlQuery = exports.sql = void 0;
const escape_identifier_1 = require("@databases/escape-identifier");
const sql_1 = require("@databases/sql");
exports.sql = sql_1.default;
Object.defineProperty(exports, "isSqlQuery", { enumerable: true, get: function () { return sql_1.isSqlQuery; } });
const split_sql_query_1 = require("@databases/split-sql-query");
const DatabaseConstructor = require("better-sqlite3");
const sqliteFormat = {
    escapeIdentifier: (str) => (0, escape_identifier_1.escapeSQLiteIdentifier)(str),
    formatValue: (value) => ({ placeholder: '?', value }),
};
class DatabaseTransactionImplementation {
    constructor(database) {
        this._database = database;
    }
    query(query) {
        return runQuery(query, this._database);
    }
    /**
     * @deprecated use queryStream
     */
    queryStream(query) {
        return runQueryStream(query, this._database);
    }
}
exports.IN_MEMORY = ':memory:';
class DatabaseConnectionImplementation {
    constructor(filename, options = {}) {
        this._database = new DatabaseConstructor(filename, options);
        this._begin = this._database.prepare('BEGIN');
        this._commit = this._database.prepare('COMMIT');
        this._rollback = this._database.prepare('ROLLBACK');
    }
    query(query) {
        return runQuery(query, this._database);
    }
    queryStream(query) {
        return runQueryStream(query, this._database);
    }
    tx(fn) {
        this._begin.run();
        try {
            const result = fn(new DatabaseTransactionImplementation(this._database));
            this._commit.run();
            return result;
        }
        catch (ex) {
            this._rollback.run();
            throw ex;
        }
    }
    dispose() {
        this._database.close();
    }
}
function connect(filename = exports.IN_MEMORY, options = {}) {
    return new DatabaseConnectionImplementation(filename, options);
}
exports.default = connect;
module.exports = Object.assign(connect, {
    default: connect,
    IN_MEMORY: exports.IN_MEMORY,
    sql: sql_1.default,
    isSqlQuery: sql_1.isSqlQuery,
});
function runQuery(query, database) {
    if (Array.isArray(query)) {
        for (const q of query) {
            if (!(0, sql_1.isSqlQuery)(q)) {
                throw new Error('Invalid query, you must use @databases/sql to create your queries.');
            }
        }
        return query.map((q) => runOneQuery(q, database));
    }
    if (!(0, sql_1.isSqlQuery)(query)) {
        throw new Error('Invalid query, you must use @databases/sql to create your queries.');
    }
    const queries = (0, split_sql_query_1.default)(query);
    const lastQuery = queries.pop();
    for (const q of queries) {
        runOneQuery(q, database);
    }
    return runOneQuery(lastQuery, database);
}
function runOneQuery(query, database) {
    const { text, values } = query.format(sqliteFormat);
    const stm = database.prepare(text);
    try {
        return stm.all(...values);
    }
    catch (_err) {
        const err = _err;
        // TODO we should be able to catch this before calling all()
        if (err.message.indexOf('This statement does not return data') >= 0) {
            stm.run(...values);
            return [];
        }
        throw err;
    }
}
function* runQueryStream(query, database) {
    if (!(0, sql_1.isSqlQuery)(query)) {
        throw new Error('Invalid query, you must use @databases/sql to create your queries.');
    }
    const { text, values } = query.format(sqliteFormat);
    const stm = database.prepare(text);
    const rows = stm.iterate(...values);
    for (const row of rows || []) {
        yield row;
    }
}
//# sourceMappingURL=index.js.map